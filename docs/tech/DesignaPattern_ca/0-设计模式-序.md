---
export: true
tags:
    - Design Pattern
---

::: info Introduction
设计模式是经过实践验证的编写代码的好的经验，在能解决需求的前提下，设计模式能够指导编写更容易被理解，更清晰，更容易修改，更易于复用，更简单等的代码。学习设计模式是学习经验。对设计模式的理解会在持续写代码的过程中不断加深，即使不学设计模式，编写好的代码的能力也会随着写代码变多而逐渐成长，学习设计模式，学习前人的经验会加快这一成长过程。

设计模式不是学完就能掌握，我需要通过持续写代码，多思考去加深对它的理解。是否应用设计模式或使用哪种设计模式没有明显的对与错，在特定视角下每一个选择都有有合适和不合适之分。

:::

## 什么是设计模式

设计模式 是复用面向对象设计的经验，在面向对象软件设计中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。设计模式所解决的问题是一般的设计问题，具体是类和相互通信的描述。

> 每一个模式描述了在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复做多余思考。

设计模式有4个基本要素：
1. 模式名称 (Pattern Name) 
2. 问题 (Problem) 描述了何时使用模式
3. 解决方案 (Solution) 描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式
4. 效果 (Consequences) 描述了模式应用的效果及使用模式应权衡的问题。模式效果包括它对系统的灵活性、扩充性或可移植性的影响，以及它对系统复杂性、可理解性或运行效率的影响。

## 设计模式分类

设计模式分为三大类： 创建型模式(Creational)、结构型模式(Structural)、行为型模式(Behavioral)。

**Abstract Factory 抽象工厂模式**: 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**Builder 建造者模式**: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

**Factory Method 工厂方法模式**: 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

**Prototype 原型模式**: 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**Singleton 单例模式**: 确保一个类只有一个实例，并提供一个全局访问点。

**Adapter 适配器模式**: 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**Bridge 桥接模式**: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。

**Composite 组合模式**: 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。

**Decorator 装饰模式**: 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。

**Facade 外观模式**: 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

**Flyweight 享元模式**: 运用共享技术有效地支持大量细粒度的对象。

**Proxy 代理模式**: 为其他对象提供一种代理以控制对这个对象的访问。

**Chain of Responsibility 责任链模式**: 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

**Command 命令模式**: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

**Interpreter 解释器模式**: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

**Iterator 迭代器模式**: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

**Mediator 中介者模式**: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

**Memento 备忘录模式**: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

**Observer 观察者模式**: 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**State 状态模式**: 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

**Strategy 策略模式**: 定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

**Template Method 模板方法模式**: 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

**Visitor 访问者模式**: 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。






## 设计模式如何解决问题

###  1. 寻找合适的对象
 
 面向对象设计最困难的部分是将系统分解成对象集合。因为要考虑许多因素：封装、粒度、依赖关系、灵活性、性能、演化、复用等，它们都影响着系统的分解，并且这些因素通常还是相互冲突的。

 设计模式帮你确定并不明显的抽象和描述这些抽象的对象。

### 2. 决定对象的粒度
 
这是面向对象设计的思考，对象的粒度首先取决于你的问题域，然后取决于你的代码结构。

### 3. 指定对象接口

**名词**

- 型构(signature)
- 接口(interface)
- 类型 (type)
  - 子类型(subtype)
  - 超类型(supertype)
- 多态 (polymorphism)
- 动态绑定(dynamic binding)   
在面向对象系统中，接口是基本的组成部分。接口和实现是分离的，两个具有相同接口的对象可以有完全不同的实现。

### 4. 描述对象的实现

类(class)和类型(type)的差别。类定义了对象是如何实现的，类型只与对象的接口有关。一个对象可以有多个类型，不同类的对象可以有相同的类型。
实现继承和接口继承。大部分语言并不区分这两者之间的区别，c++中，纯接口继承接近于共有继承纯抽象类，纯实现继承或纯类继承接近于私有继承。

**对接口编程，而不是对实现编程** 这种思想天然的导向减少系统之间的依赖关系。

### 5. 运用复用机制

复用：
- 继承和组合。 **优先使用对象组合，而不是类继承**
- 委托
- 参数化类型 (parameterized type) generic 或者 templates


软件设计的三个方向：

1. 应用程序 (application)
2. 工具箱 (toolkit)
3. 框架 (framework)

写框架更难，设计模式能够帮助理解框架，设计模式和框架之间的关系： 设计模式比框架更加抽象，框架比设计模式更加特例化，设计模式是比框架更小的体系结构元素。

## 选择设计模式


- 考虑设计模式是怎样解决设计问题的
- 浏览模式的意图部分
- 研究目的相似的模式
- 检查重新设计的原因
- 考虑你的设计中那些是可变的

## 使用设计模式

- 大致浏览一遍设计模式
- 回头研究结构部分、参与者部分和协作部分
- 看代码示例部分，看看这个模式代码形式的具体例子
- 选择模式参与者的名字，使它们在应用上下文中有意义
- 定义类
- 定义模式中专用于应用的操作名称
- 实现执行模式中责任和协作的操作

设计模式的使用限制： 只有需要设计模式的时候才去使用设计模式，设计模式提供了灵活性，但是它让设计变得更复杂或者牺牲了一定的性能。
